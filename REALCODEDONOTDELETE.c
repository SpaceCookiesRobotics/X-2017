#pragma config(Motor,  port2,           CHFrontRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           CHFrontLeft,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           CHBackRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LiftRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           SULeft,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           SURight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           CHBackLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LiftLeft,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "../Shared/Competition.h"
//1 = left side
//0 = right side
int autonomousMode = 1;

int armSpeed = 127;

bool stayClosed = false;

//Chassis controls
void forward (int time){
	motor[CHFrontRight] = 256;
	motor[CHFrontLeft] = 256*3;
	motor[CHBackRight] = 256;
	motor[CHBackLeft] = 256*3;
	wait1Msec(time);
}
/*
void backward (int time){
motor[CHFrontRight] = -256;
motor[CHFrontLeft] = -256;
motor[CHBackRight] = -256;
motor[CHBackLeft] = -256;
wait1Msec(time);
}
*/

void turnRight (int time){
	motor[CHFrontRight] = 256;
	motor[CHFrontLeft] = -256;
	motor[CHBackRight] = 256;
	motor[CHBackLeft] = -256;
	wait1Msec(time);
}

void turnLeft (int time){
	motor[CHFrontRight] = -256;
	motor[CHFrontLeft] = 256;
	motor[CHBackRight] = -256;
	motor[CHBackLeft] = 256;
	wait1Msec(time);
}
//Claw
void clawMovement (bool open) {
	if (open) {
		motor[Claw] = -75;

	}
	else {
		motor[Claw] = 75;

	}
	// motor[Claw] = 0;
}
//Lift
/*
void MoveLift (bool liftup) {
if (liftup) {
motor[LiftRight] = 127;
motor[LiftLeft] = 127;
wait1Msec(100);
}


else {
motor[LiftRight] = -1*(127/2);
motor[LiftLeft] = -1*(127/2);
wait1Msec(500);
}
*/

//Lift control
/*
task LiftUp () {
MoveLift(true);
}
task LiftDown () {
MoveLift(false);
}
*/
//Claw control
void OpenClaw(){
	clawMovement(true);
}
void CloseClaw(){
	clawMovement(false);
}
//Tower control
void towerMovement (int time, bool up) {
	if (up) {
		motor[SULeft] = armSpeed;
		motor[SURight] = armSpeed;
		wait1Msec(time);
	}
	else {
		motor[SULeft] = -1*armSpeed/2;
		motor[SURight] = -1*armSpeed/2;
		wait1Msec(time);
	}
}
task ArmUP(){
	towerMovement(700,true);
}
task ArmDown(){
	towerMovement(800,false);
}

//robot controls
void autonomous() {
	/*if (autonomousMode == 0) {
		clawMovement(true);
		turnRight(200);
		forward(100);
		towerMovement(550, true);
		clawMovement(false);
		towerMovement(250, false);
		turnLeft(250);
		forward(250);
		} else if (autonomousMode == 1){
		clawMovement(true);
		turnLeft(200);
		forward(100);
		towerMovement(550, true);
		clawMovement(false);
		towerMovement(250, false);
		turnRight(250);
		forward(250);
	}
	*/
}
//Limit switch
/*function limitSwitchInput() {
return(sensorValue[dgtl1])
}*/
task HandleClaw() {
	while (true) {
		if (vexRT[Btn6UXmtr2] == 1){
			OpenClaw();
			stayClosed = false;
		}
		if (vexRT[Btn6DXmtr2] == 1){
			CloseClaw();
			stayClosed = true;
		}
		if (vexRT[Btn6UXmtr2] == 0 && vexRT[Btn6DXmtr2] == 0){
			if (stayClosed) {
				motor[Claw] = 25;
			}
			else {
				motor[Claw] = 0;
			}
		}
	}
}
task HandleLift() {
	while(true) {
		motor[SURight] = vexRT[Ch3Xmtr2]/2;
		motor[SULeft] = vexRT[Ch3Xmtr2]/2;
	}
}

void joystick() {
	startTask (HandleClaw);
  startTask (HandleLift);
	while (true) {
		motor[CHFrontRight] = vexRT[Ch2];
		motor[CHFrontLeft] = vexRT[Ch3];
		motor[CHBackRight] = vexRT[Ch2];
		motor[CHBackLeft] = vexRT[Ch3];
	}
}

/*task main() {
joystick();
}*/

//autonomous (going to stationary goal, start on left hand side)

//Right side autonomous (same as above but sides revers
/*void autonomous() {
clawMovement(true);
turnLeft(1000);
forward(4000);
towerMovement(500, true);
clawMovement(false);
towerMovement(500, false);
turnLeft(1000);
forward(4000);
}*/
