#pragma config(Motor,  port2,           CHFrontRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           CHFrontLeft,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           CHBackRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           CHBackLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           SULeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           SURight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LiftRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LiftLeft,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "../Shared/Competition.h"



void forward (int time){
	motor[CHFrontRight] = 256;
	motor[CHFrontLeft] = 256;
	motor[CHBackRight] = 256;
	motor[CHBackLeft] = 256;
	wait1Msec(time);
}

void backward (int time){
	motor[CHFrontRight] = -256;
	motor[CHFrontLeft] = -256;
	motor[CHBackRight] = -256;
	motor[CHBackLeft] = -256;
	wait1Msec(time);
}

void turnRight (int time){
	motor[CHFrontRight] = 256;
	motor[CHFrontLeft] = -256;
	motor[CHBackRight] = 256;
	motor[CHBackLeft] = -256;
	wait1Msec(time);
}

void turnLeft (int time){
	motor[CHFrontRight] = -256;
	motor[CHFrontLeft] = 256;
	motor[CHBackRight] = -256;
	motor[CHBackLeft] = 256;
	wait1Msec(time);
}

void clawMovement (bool open) {
	if (open) {
		motor[Claw] = 256;
		wait1Msec(500);
	}
	else {
		motor[Claw] = -256;
		wait1Msec(500);
	}
}

void MoveLift (bool liftup) {
	if (liftup) {
		motor[LiftRight] = 100*10;
		motor[LiftLeft] = 100*10;
		wait1Msec(100);
	}
	else {
		motor[LiftRight] = -50;  // slow
		motor[LiftLeft] = -50;
		wait1Msec(500);
	}
}

task OpenClaw(){
	clawMovement(true);
}
task CloseClaw(){
	clawMovement(false);
}

void towerMovement (int time, bool up) {
	if (up) {
		motor[SULeft] = 256;
		motor[SURight] = 256;
		wait1Msec(time);
	}
	else {
		motor[SULeft] = -256;
		motor[SURight] = -256;
		wait1Msec(time);
	}
}
task ArmUP(){
	towerMovement(700,true);
}
task ArmDown(){
	towerMovement(800,false);
}
//autonomous (going to stationary goal, start on left hand side)

//Right side autonomous (same as above but sides revers
/*void autonomous() {
clawMovement(true);
turnLeft(1000);
forward(4000);
towerMovement(500, true);
clawMovement(false);
towerMovement(500, false);
turnLeft(1000);
forward(4000);
}*/

//robot controls
void autonomous() {
	clawMovement(true);
	turnRight(1000);
	forward(4000);
	towerMovement(500, true);
	clawMovement(false);
	towerMovement(500, false);
	turnRight(1000);
	forward(4000);
}

void joystick() {
	while (true) {
		motor[CHFrontRight] = vexRT[Ch2]*2;
		motor[CHFrontLeft] = vexRT[Ch3]*2;
		motor[CHBackRight] = vexRT[Ch2]*2;
		motor[CHBackLeft] = vexRT[Ch3]*2;
		motor[SURight] = vexRT[Ch3Xmtr2]/2;
		motor[SULeft] = vexRT[Ch3Xmtr2]/2;
		if (vexRT[Btn5UXmtr2] == 1){
			startTask (ArmUP);
		}
		if (vexRT[Btn5DXmtr2] == 1){
			startTask (ArmDown);
		}
		if (vexRT[Btn6UXmtr2] == 1){
			startTask (OpenClaw);
		}
		if (vexRT[Btn6DXmtr2] == 1){
			startTask (CloseClaw);
		}
	}
}

task main() {
   joystick();
}
