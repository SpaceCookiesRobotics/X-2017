#pragma config(Motor,  port2,           CHFrontRight,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           CHFrontLeft,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           CHBackRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           CHBackLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           SULeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           SURight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           motor8,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motor9,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "../Shared/Competition.h"

void forward (int time){
	motor[CHFrontRight] = 256;
	motor[CHFrontLeft] = 256;
	motor[CHBackRight] = 256;
	motor[CHBackLeft] = 256;
	wait1Msec(time);
}

void backward (int time){
	motor[CHFrontRight] = -256;
	motor[CHFrontLeft] = -256;
	motor[CHBackRight] = -256;
	motor[CHBackLeft] = -256;
	wait1Msec(time);
}

void turnRight (int time){
	motor[CHFrontRight] = 256;
	motor[CHFrontLeft] = -256;
	motor[CHBackRight] = 256;
	motor[CHBackLeft] = -256;
	wait1Msec(time);
}

void turnLeft (int time){
	motor[CHFrontRight] = -256;
	motor[CHFrontLeft] = -256;
	motor[CHBackRight] = -256;
	motor[CHBackLeft] = -256;
	wait1Msec(time);
}

void clawMovement (bool open) {
	if (open) {
		motor[motor8] = 256;
		wait1Msec(500);
	}
	else {
		motor[motor8] = -256;
		wait1Msec(500);
	}
}

task OpenClaw(){
	clawMovement(true);
}
task CloseClaw(){
	clawMovement(false);
}


void wristMovement (int time, bool num) {
	if (num == 0) {
		motor[motor9] = 256;
		wait1Msec(time);
	}
	else {
		motor[motor9] = -256;
		wait1Msec(time);
	}
}

void towerMovement (int time, bool up) {
	if (up) {
		motor[SULeft] = 256;
		motor[SURight] = 256;
		wait1Msec(time);
	}
	else {
		motor[SULeft] = -256;
		motor[SURight] = -256;
		wait1Msec(time);
	}
}
task ArmUP(){
	towerMovement(700,true);
}
task ArmDown(){
	towerMovement(800,false);
}
//autonomous (going to stationary goal, start on left hand side)
void autonomous() {
	clawMovement(true);
	turnRight(1000);
	forward(4000);
	towerMovement(500, true);
	clawMovement(false);
	towerMovement(500, false);
	turnRight(1000);
	forward(4000);
}
//Right side autonomous (same as above but sides reversed)
/*void autonomous() {
clawMovement(true);
turnLeft(1000);
forward(4000);
towerMovement(500, true);
clawMovement(false);
towerMovement(500, false);
turnLeft(1000);
forward(4000);
}*/

//robot controls
void joystick() {
	while (true) {
		motor[CHFrontRight] = vexRT[Ch2]*2;
		motor[CHFrontLeft] = vexRT[Ch3]*2;
		motor[CHBackRight] = vexRT[Ch2]*2;
		motor[CHBackLeft] = vexRT[Ch3]*2;
		motor[SURight] = vexRT[Ch3Xmtr2]/2;
		motor[SULeft] = vexRT[Ch3Xmtr2]/2;
		if (vexRT[Btn5UXmtr2] == 1){
			startTask (ArmUP);
		}
		if (vexRT[Btn5DXmtr2] == 1){
			startTask (ArmDown);
		}
		if (vexRT[Btn6UXmtr2] == 1){
			startTask (OpenClaw);
		}
		if (vexRT[Btn6DXmtr2] == 1){
			startTask (CloseClaw);
		}
	}
}
